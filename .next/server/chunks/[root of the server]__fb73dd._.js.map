{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 63, "column": 0}, "map": {"version":3,"sources":["file:///Users/michaelsalama/Documents/Michael/chrome/nearestmountain/nearest-mountain/app/api/nearestMountain/route.js"],"sourcesContent":["import { promises as fs } from \"fs\";\nimport path from \"path\";\n\nexport async function GET(req) {\n    try {\n        const { searchParams } = new URL(req.url);\n        const lat = parseFloat(searchParams.get(\"lat\"));\n        const lon = parseFloat(searchParams.get(\"lon\"));\n        const minElevation = parseFloat(searchParams.get(\"minElevation\")) || 0;\n\n        if (isNaN(lat) || isNaN(lon)) {\n            return new Response(JSON.stringify({ error: \"Invalid coordinates\" }), { status: 400 });\n        }\n\n        // Load CSV data\n        const filePath = path.join(process.cwd(), \"public\", \"GMBA.csv\");\n        const csvData = await fs.readFile(filePath, \"utf-8\");\n\n        // Convert CSV data to an array of objects\n        const mountains = csvData.split(\"\\n\").slice(1).map((line) => {\n            const columns = line.split(\",\");\n            return {\n                name: columns[3],\n                lat: parseFloat(columns[39]),\n                lon: parseFloat(columns[40]),\n                elevation_low: parseInt(columns[36]),\n                elevation_high: parseInt(columns[37]),\n                range: columns[10],\n                countries: columns[43],\n                region: columns[8],\n                map_unit: columns[31],\n            };\n        }).filter(m => !isNaN(m.lat) && !isNaN(m.lon) && m.map_unit !== \"Aggregated\");\n\n        // Haversine function\n        function haversine(lat1, lon1, lat2, lon2) {\n            const R = 6371;\n            const toRad = (deg) => (deg * Math.PI) / 180;\n            const dLat = toRad(lat2 - lat1);\n            const dLon = toRad(lon2 - lon1);\n            const a = Math.sin(dLat / 2) ** 2 +\n                Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;\n            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        }\n\n        // Find the 10 nearest mountains above minElevation\n        let nearestMountains = [];\n\n        mountains.forEach(mountain => {\n            if ((mountain.elevation_high >= minElevation) || (mountain.elevation_low >= minElevation)) {\n                const distance = haversine(lat, lon, mountain.lat, mountain.lon);\n\n                // Maintain a sorted list of 10 closest mountains\n                if (nearestMountains.length < 10) {\n                    nearestMountains.push({ ...mountain, distance });\n                    nearestMountains.sort((a, b) => a.distance - b.distance);\n                } else if (distance < nearestMountains[9].distance) {\n                    nearestMountains[9] = { ...mountain, distance };\n                    nearestMountains.sort((a, b) => a.distance - b.distance);\n                }\n            }\n        });\n\n        if (nearestMountains.length === 0) {\n            return new Response(JSON.stringify({ error: \"No mountains found above the specified elevation\" }), { status: 404 });\n        }\n\n        // Return the ordered list of 10 nearest mountains\n        return new Response(JSON.stringify(nearestMountains), {\n            status: 200,\n            headers: { \"Content-Type\": \"application/json\" },\n        });\n\n    } catch (error) {\n        console.error(\"Error processing request:\", error);\n        return new Response(JSON.stringify({ error: \"Internal Server Error\" }), { status: 500 });\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 154, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}
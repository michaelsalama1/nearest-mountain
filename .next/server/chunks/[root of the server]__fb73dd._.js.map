{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 63, "column": 0}, "map": {"version":3,"sources":["file:///Users/michaelsalama/Documents/Michael/chrome/nearestmountain/nearest-mountain/app/api/nearestMountain/route.js"],"sourcesContent":["import { promises as fs } from \"fs\";\nimport path from \"path\";\n\nexport async function GET(req) {\n    try {\n        // Parse query parameters\n        const { searchParams } = new URL(req.url);\n        const lat = parseFloat(searchParams.get(\"lat\"));\n        const lon = parseFloat(searchParams.get(\"lon\"));\n        const minElevation = parseFloat(searchParams.get(\"minElevation\")) || 0; // Default to 0 if not provided\n\n        if (isNaN(lat) || isNaN(lon)) {\n            return new Response(JSON.stringify({ error: \"Invalid coordinates\" }), { status: 400 });\n        }\n\n        // Load the CSV data\n        const filePath = path.join(process.cwd(), \"public\", \"GMBA.csv\");\n        const csvData = await fs.readFile(filePath, \"utf-8\");\n\n        // Convert CSV data to an array of objects\n        const mountains = csvData.split(\"\\n\").slice(1).map((line) => {\n            const columns = line.split(\",\");\n            return {\n                name: columns[3], // Assuming column 3 is the mountain name\n                lat: parseFloat(columns[39]), // Assuming column 39 is latitude\n                lon: parseFloat(columns[40]), // Assuming column 40 is longitude\n                elevation_low: parseInt(columns[37]), // Assuming column 35 is low elevation\n                elevation_high: parseInt(columns[38]), // Assuming column 36 is high elevation\n                range: columns[10], // Assuming column 28 is the range\n                countries: columns[43], // Assuming column 43 is the countries\n                regions: columns[48], // Assuming column 48 is regions\n                map_unit: columns[31], // Assuming column 32 is the type (Basic or Aggregated)\n            };\n        }).filter(m => !isNaN(m.lat) && !isNaN(m.lon) && m.map_unit !== \"Aggregated\"); // Filter rows where type is not \"Aggregated\"\n\n        // Find the nearest mountain with elevation above the minimum threshold\n        let nearest = null;\n        let minDistance = Infinity;\n\n        function haversine(lat1, lon1, lat2, lon2) {\n            const R = 6371; // Radius of Earth in km\n            const toRad = (deg) => (deg * Math.PI) / 180;\n            const dLat = toRad(lat2 - lat1);\n            const dLon = toRad(lon2 - lon1);\n            const a = Math.sin(dLat / 2) ** 2 +\n                Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;\n            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        }\n\n        mountains.forEach(mountain => {\n            // Only consider mountains that are above the minElevation\n            if ((mountain.elevation_high >= minElevation) || (mountain.elevation_low >= minElevation)) {\n                const distance = haversine(lat, lon, mountain.lat, mountain.lon);\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    nearest = mountain;\n                }\n            }\n        });\n\n        if (!nearest) {\n            return new Response(JSON.stringify({ error: \"No mountains found above the specified elevation\" }), { status: 404 });\n        }\n\n        return new Response(JSON.stringify({\n            name: nearest.name,\n            latitude: nearest.lat,\n            longitude: nearest.lon,\n            distance_km: minDistance.toFixed(2),\n            range: nearest.range,\n            countries: nearest.countries,\n            elevation_low: nearest.elevation_low,\n            elevation_high: nearest.elevation_high,\n            elevation_range: nearest.elevation_high - nearest.elevation_low,\n            regions: nearest.regions,\n            map_unit: nearest.map_unit,\n        }), {\n            status: 200,\n            headers: { \"Content-Type\": \"application/json\" },\n        });\n\n    } catch (error) {\n        console.error(\"Error processing request:\", error);\n        return new Response(JSON.stringify({ error: \"Internal Server Error\" }), { status: 500 });\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}